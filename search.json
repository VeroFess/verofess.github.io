[{"title":"一些网络安全方面的基础科普 - P1 识别恶意软件[尚未完成]","url":"/d4ad30414b22/","content":"这几天看到了一些比较肆虐而且比较常见的互联网病毒传播，所以专门写篇文章聊一聊这个问题\n特别一提，由于本文的性质，本文章为公共领域文章，即在世界范围内放弃本文的所有权利，故任何人都可以以任何方式转载或重新发布\n当然，如果你可以保留指向本文章的链接那就再好不过了，因为本文章可能会更新，保留链接可以使读者获得及时的更新\n本文章虽然是面向Windows的，但是安卓或者其他平台举一反三也可以用，本文章的方案只是个人经验，常在河边走总会踩进去！\n01 手把手的入门! 浅谈一下比较泛用的病毒(恶意软件)识别方式01-1 万事开头难: 误报对于对信息安全方面不太熟悉的朋友来说，有一个词很熟悉: 误报\n误报这个问题具体来说就是因为某些软件(外挂, 破解器)的行为和病毒实在是太像了，导致杀毒软件不能准确的识别\n于是有些病毒作者就把思路打开了: 如果杀毒软件会把病毒和破解工具搞混，那是不是可以把他们捆绑在一起让用户手动放行呢？\n没错，是这样的，并且有很大一部分的病毒也正是这样传播的，所以，支持正版，不要开挂是预防病毒很好的手段\n哎哎别关网页，肯定有人要说了: “你这说了个JB”，别慌，接下来是正题\n看之前请记住，以下的分析并不能替代杀毒软件的动态监测\n也请不要抱着: 我也没啥值钱的东西感染就感染了呗\n现代的木马盗号已经是轻的了，冒充你的信息贷款，使用你的电脑攻击其他设备或者进行其他违法行为才是需要警惕的，毕竟警察看到的是从你的设备发出的攻击\n01-2 Virus Total: 简单，高效的恶意文件分析识别网站接下来，就是我们的正题: 如何将外挂等工具与木马病毒区分开来\n当然，如果你是卡巴斯基用户…只需要右键一下…\n\n咳咳，跑题了，先放链接: Virus Total\n打开上面的链接，你会看到这样的页面\n\nOK, 这就是我们的主角了，具体它是什么网站感兴趣的可以自行查询\n主页很简单，点击 Choose file 按钮或者将文件拖拽到中间的图标上[参考下图]即可上传文件进行分析\n\n拖拽上去之后，如果你的文件从来没有人上传过，会弹出一个窗口要求你确认上传[参考下图]，点击中间的 Confirm upload 按钮即可上传。 请注意，你所上传的文件，对于专业的安全研究人员来说，是可以下载的，请不要上传涉及机密以及个人隐私的文件\n\n新的文件可能需要一些时间来扫描，等扫描结束之后，我们即可看到结果页面，大概长下面这样\n\n首先，最主要的部分就是文件安全概览部分，也就是下图中的部分\n\n左边的圆环 [图中标有 1 的方框] 代表着有多少杀毒软件认为这个文件是带有恶意的，在这张图中，总共有70个杀毒软件对文件进行了扫描，其中有0个杀毒软件将其汇报为恶意\n圆环的下方 [图中标有 2 的方框] 代表有多少VT的用户认为这个文件是恶意或者善意的，图中只有我自己投了一票，所以上面的评分是问号。这个评分是个人就能投，目前对于恶意刷票是否有惩罚我没有了解，所以它并不能权威的表示这个文件具体的行为，但是具有一定的参考价值\n在整体靠右的位置 [图中标有 3 的方框]，代表这个文件第一次上传是什么时候，可以看到我选择的文件在五天前第一次被上传，通常来说，较旧的文件(大于半年)的结果是比较准确的，因为不明确的文件大概率都被各大安全公司已经拖回去手动分析过了，而较新的文件可能存在漏检的问题，因为病毒也会尝试新的技术来躲避杀毒软件的追踪\n继续向下看，就可以看到几个分页 [见下图]，点击任意标题即可跳转到对应的页，四个标签分别对应着 **杀毒软件检测结果 [图中标有1的方框]，文件详情 [图中标有2的方框]，该文件的行为(就是他执行之后干了啥) [图中标有3的方框]，社区评分的详情 [图中标有4的方框，对应上一张图的2号框]**，\n\n其中，我们在 杀毒软件检测结果 页中，主要关注 如果杀毒软件报毒，那么杀毒软件认为他是个什么东西，即下图中红色字体的部分 (下图中，为了演示我换了一个报毒的样本)\n\n而另外几个标签页，则会结合杀毒软件检测结果中的信息综合使用，详见下文\n在接下来的文章中，我会选择四类文件进行分析，分别是 完全可信的文件, 大概率可信的文件, 有疑点但是也许可信的文件, 大概率不可信的文件，并向大家指出如何区分它们.\n01-3 典型的完全可信文件这一部分最为简单，一个典型的白名单文件应该做到什么呢？代码透明，没有恶意行为，有可信任的文件发布者，满足这点即可放心的使用\n在这里，我使用了自己的 EV 证书签名了一个来自 Google Android Platform Tools 的文件，并将其上传至 Virus Total，可以点击这个链接 查看\n对于这个文件，72个杀毒软件对其进行了测试，其中有0个杀毒软件将其标记为了病毒\n同时我们点击文件详情(忘了在哪里？回去看看吧 XD)， 向下拖，可以看到有一个叫做签名信息的区域，其中有一行带有绿色对勾的 Signed file, valid signature , 表明该文件经过了数字签名(什么是数字签名? 点这里 或者 点这里 查看科普)，同时该文件的签名人持有的是EV证书(什么是EV证书? 点这里查看科普) 所以该文件大概率是可信的. [见下图]\n\n01-4 大概率可信的文件这里我们选择了一个来自 Github 的文件，其报告可以从 这里 查看，大部分情况下，我们使用的一些小工具并没有进行数字签名(贵啊!)，不过相对来说，还是比较好区分的\n首先，没有任何杀毒软件对其报毒，这很好，其次，虽然它没有签名，但是他也没有任何的异常行为(见下图红框)，所以我们认为他是可信的\n\n01-5 有疑点但是也许可信的文件接下来，也就是本文的重点难点，怎么样区分误报和真正的恶意软件\n首先，先回顾一个问题: 为什么会有误报发生? 是因为某些软件(外挂, 破解器)的行为和病毒实在是太像了，导致杀毒软件不能准确的识别\n那么，人工怎么识别呢？有三个关键点，分别是：行为合理性，报毒种类以及综合风险\n… 未完待续\n","categories":[],"tags":[]},{"title":"CSharp中实现一个可继承的Singleton基类","url":"/f72f727a78aa/","content":"网上大部分的单例实现都要求在类里添加一个”GetInstance()”并且声明私有的构造函数,额外多了几行没啥用且重复的代码,一不小心还会忘记把构造函数搞成私有的,非常不爽,所以就搞了个这东西\n不多说,上代码,使用的时候只需要public class ClassName : Singleton&lt;ClassName&gt;即可,获取实例直接ClassName.Instance,无需额外的更改\nusing System;using System.Collections.Generic;namespace InstanceHelper.Singleton &#123;    public class Singleton&lt;T&gt; &#123;        private static Dictionary&lt;Type, Object&gt; TypeObjectMap = new Dictionary&lt;Type, Object&gt;();        private static List&lt;Type&gt; TypeLoadList = new List&lt;Type&gt;();        static public T Instance &#123; get =&gt; GetInstance(typeof(T)); &#125;        public Singleton() &#123;            lock (TypeLoadList) &#123;                if (!TypeLoadList.Contains(this.GetType())) &#123;                    throw new NewSingletonClassException(String.Format(&quot;Class &#123;0&#125; is Singleton, Use \\&quot;&#123;1&#125;.Instance;\\&quot; but \\&quot;new &#123;1&#125;();\\&quot;&quot;, this.GetType().FullName, this.GetType().Name));                &#125;            &#125;        &#125;        private static void LockUnregisterTypeLoadStatus(Type _Type) &#123;            lock (TypeLoadList) &#123;                if (TypeLoadList.Contains(_Type)) &#123;                    TypeLoadList.Remove(_Type);                &#125;            &#125;        &#125;        private static void LockRegisterTypeLoadStatus(Type _Type) &#123;            lock (TypeLoadList) &#123;                if (!TypeLoadList.Contains(_Type)) &#123;                    TypeLoadList.Add(_Type);                &#125;            &#125;        &#125;        protected static T GetInstance(Type _Type) &#123;            if (!TypeObjectMap.ContainsKey(_Type)) &#123;                lock (TypeObjectMap) &#123;                    if (!TypeObjectMap.ContainsKey(_Type)) &#123;                        LockRegisterTypeLoadStatus(_Type);                        var Instance = Activator.CreateInstance(_Type);                        LockUnregisterTypeLoadStatus(_Type);                        TypeObjectMap.Add(_Type, Instance);                    &#125;                &#125;            &#125;            return (T)TypeObjectMap[_Type];        &#125;    &#125;&#125;","categories":["开发笔记"],"tags":["CSharp"]},{"title":"一份面向Linux下高版本Java的Minecraft参数优化教程","url":"/e6ad4dc21152/","content":"前排提示:[!] 注意，该教程仅面向具有独立服务器的情况，如果你是面板服，就不用看了[!] 注意，该教程假定你有一块还算不错的CPU,2.XHz的就别看了[!] 注意，该教程需要一定的Linux知识，并且假定你正在使用Ubuntu，其它系统自己百度0. 一些废话和声明Q: 为什么要写这一篇帖子？\nA: 这两天在开服，随手翻看了几篇优化帖子，发现都是基于老版本Java的，于是就想写一篇新的。\n\nQ: 我可以转载这篇帖子么？\nA: 很抱歉，你不可以这么做，除非你联系我(MCBBS, Twitter, 知乎：@VeroFess)并获得了明确的授权\n\n\n1. 服务器准备1.1 升级Java为啥要升级Java？很简单，更新的Java可以获得更好的性能，但是在高版本里其实你选择哪个Java的影响已经不是很大了。\n不论如何，请使用你的方法安装Java 17，最好是Jdk, 完成后， 输入 java --version, 来检查一下是否安装正常\n你应该可以看到类似的输出\n$ java --versionopenjdk 17.0.3 2022-04-19OpenJDK Runtime Environment (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)OpenJDK 64-Bit Server VM (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1, mixed mode, sharing)\n\n1.2 开启大页支持大页 (LargePages) 究竟有什么好处并不是我们今天的重点，一句话来说就是可以让你白捡百分之十几的性能\n当然，在动手前，让我们先试一试是不是系统已经支持了这项功能\n在控制台中， 输入 java -Xlog:gc+init -XX:+UseLargePages -Xmx1g -version , 你应该会看到类似的输出\n$ java -Xlog:gc+init -XX:+UseLargePages -Xmx1g -version[0.000s][warning][pagesize] UseLargePages disabled, no large pages configured and available on the system.[0.023s][info   ][gc,init ] Version: 17.0.3+7-Ubuntu-0ubuntu0.20.04.1 (release)[0.023s][info   ][gc,init ] CPUs: 16 total, 16 available[0.023s][info   ][gc,init ] Memory: 31972M[0.023s][info   ][gc,init ] Large Page Support: Disabled[0.023s][info   ][gc,init ] NUMA Support: Disabled[0.023s][info   ][gc,init ] Compressed Oops: Enabled (32-bit)[0.023s][info   ][gc,init ] Heap Region Size: 1M[0.023s][info   ][gc,init ] Heap Min Capacity: 8M[0.023s][info   ][gc,init ] Heap Initial Capacity: 500M[0.023s][info   ][gc,init ] Heap Max Capacity: 1G[0.023s][info   ][gc,init ] Pre-touch: Disabled[0.023s][info   ][gc,init ] Parallel Workers: 13[0.023s][info   ][gc,init ] Concurrent Workers: 3[0.023s][info   ][gc,init ] Concurrent Refinement Workers: 13[0.023s][info   ][gc,init ] Periodic GC: Disabledopenjdk version &quot;17.0.3&quot; 2022-04-19OpenJDK Runtime Environment (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)OpenJDK 64-Bit Server VM (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1, mixed mode, sharing)\n\n如果你像我一样， 有一行 UseLargePages disabled, no large pages configured and available on the system. 那么就说明当前系统并不支持大页，不过不要急，可以试一下这一行命令 java -Xlog:gc+init -XX:+UseTransparentHugePages -Xmx1g -version , 你应该会看到类似的输出：\n$ java -Xlog:gc+init -XX:+UseTransparentHugePages -Xmx1g -version[0.024s][info][gc,init] Version: 17.0.3+7-Ubuntu-0ubuntu0.20.04.1 (release)[0.024s][info][gc,init] CPUs: 16 total, 16 available[0.024s][info][gc,init] Memory: 31972M[0.024s][info][gc,init] Large Page Support: Enabled (Transparent)[0.024s][info][gc,init] NUMA Support: Disabled[0.024s][info][gc,init] Compressed Oops: Enabled (32-bit)[0.024s][info][gc,init] Heap Region Size: 1M[0.024s][info][gc,init] Heap Min Capacity: 8M[0.024s][info][gc,init] Heap Initial Capacity: 500M[0.024s][info][gc,init] Heap Max Capacity: 1G[0.024s][info][gc,init] Pre-touch: Disabled[0.024s][info][gc,init] Parallel Workers: 13[0.024s][info][gc,init] Concurrent Workers: 3[0.024s][info][gc,init] Concurrent Refinement Workers: 13[0.024s][info][gc,init] Periodic GC: Disabledopenjdk version &quot;17.0.3&quot; 2022-04-19OpenJDK Runtime Environment (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)OpenJDK 64-Bit Server VM (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1, mixed mode, sharing)\n\n注意到 Large Page Support: Enabled (Transparent) 了么？说明我们的系统是支持透明大页的。\n但是如果你依然不支持或者想要追求极致性能，可以去百度搜索当前的系统如何开启大页，这里就不再过多的赘述了。\n\n2. 启动参数2.1 G1GC vs.ZGCGC引擎的选择是一个老生常谈的问题了，同其他教程不同，我本人更加推荐ZGC。\n理由很简单，现在的CPU动辄八核十六核，但是MC又是一个出了名的吃单核游戏，用其他核心的时间换主核心的无暂停是很划算的事情。\nG1GC在设计之初考虑的是吞吐量和占用的均衡，而ZGC则是用更加高昂的CPU代价换取主线程无停顿，这对我们来说简直是刚好。但是并不是每一个人都适合ZGC，在接下来的文章里我会教你怎么样查看自己适不适合它。\n2.2 来吧！启动参数！2.2.1 总览准备好, 参数要来了，有点长，不过我会分段告诉你他们的作用。\njava -server -Xmx$&#123;memory&#125;M -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+DisableExplicitGC -XX:-UseG1GC -XX:+UseZGC -XX:-ZUncommit -XX:+UseTransparentHugePages -XX:+UseHugeTLBFS -XX:LargePageSizeInBytes=1g -XX:ReservedCodeCacheSize=512M -XX:MaxInlineSize=256 -XX:+AlwaysPreTouch -XX:+OmitStackTraceInFastThrow -XX:+DoEscapeAnalysis -XX:+OptimizeStringConcat -XX:+EliminateLocks -XX:+UseBiasedLocking -XX:+SegmentedCodeCache -XX:+UseVectorCmov -XX:+UseSHM -XX:+UseNewLongLShift -XX:+UseFastStosb -jar $&#123;core&#125;.jar\n2.2.2 那些不太需要说的部分-Xmx$&#123;memory&#125;M 和 -jar $&#123;core&#125;.jar 这两个参数，着实是不用说…\n2.2.3 基础！-server 这个参数吧，我自己测试确实是有一定的效果的，但是也没其他帖子说的这么夸张，总之加上肯定没错。\n而 -XX:+UnlockExperimentalVMOptions 和 -XX:+UnlockDiagnosticVMOptions 这两个参数，纯粹是我懒得去看后面的一大串是不是在他们的影响列表里，所以加上的。\n2.2.4 内存管理调整-XX:+DisableExplicitGC，-XX:-UseG1GC，-XX:+UseZGC，-XX:-ZUncommit，-XX:+UseTransparentHugePages，-XX:+UseHugeTLBFS，-XX:LargePageSizeInBytes=1g，-XX:ReservedCodeCacheSize=512M，-XX:MaxInlineSize=256和-XX:+AlwaysPreTouch属于内存调整参数。\n首先，我们通过-XX:+DisableExplicitGC来阻止显式的System.gc()调用，这倒不是说所有的手动调用都是不好的，但是总有些mod或者插件的编写者觉得调用的越频繁越好，但是过于频繁的GC反而会拖慢速度，所以索性就把这个方法干掉，让Java来帮我们管理。\n-XX:-UseG1GC，-XX:+UseZGC 这两个参数用来强制Jvm使用ZGC, 不需要做过多的解释\n-XX:-ZUncommit， -XX:+AlwaysPreTouch 这两个参数呢，要求Jvm总是提前把要用的内存申请好，并且阻止Jvm把临时空出来的内存还给系统，这样会节约不少内存分配的开销，当然，如果你的系统内存不够用，还是去掉这两个参数吧。\n-XX:+UseTransparentHugePages，-XX:+UseHugeTLBFS，-XX:LargePageSizeInBytes=1g 这三个参数用于启用大页支持，并且允许Jvm使用1G的大页， 如果你的系统支持非透明大页（也就是1.2中的第一个指令没有说不支持），就把-XX:+UseTransparentHugePages给改成-XX:+UseLargePages.\n-XX:ReservedCodeCacheSize=512M，-XX:MaxInlineSize=256这两个参数允许Jvm缓存更多Jit之后的代码，并且允许Jvm把一些比较短的方法做inline优化，是一种用比较小的内存代价来换取性能提升的方法。\n2.2.5 其他优化这一部分主要包含了 -XX:+OmitStackTraceInFastThrow， -XX:+DoEscapeAnalysis， -XX:+OptimizeStringConcat， -XX:+EliminateLocks 这四个参数。\n-XX:+OmitStackTraceInFastThrow 这个参数要求Jvm在遇到异常时省略异常栈，因为有一些编写不是很好的mod&#x2F;插件总是会抛出异常，这也算是一个可能不小的优化。\n-XX:+DoEscapeAnalysis 这个参数应该是默认启用的，他要求Jvm进行逃逸分析，并且以分析结果为依据进行其他优化，这里加上只是为了防止某些个例中这玩意由于未知原因被关掉。\n-XX:+OptimizeStringConcat 同样， 这个也应该是默认启用的，可以优化字符串拼接的效率。\n-XX:+SegmentedCodeCache 这个选项要求Jit编译器把代码拆分为小段，虽然会占用更多的内存，但是会加快运行的速度。\n-XX:+UseBiasedLocking 这个选项要求使用偏向锁，由于MC的锁竞争大多发生在主线程，这可以优化一些性能，虽然提示这个东西要移除了，但是能用一天是一天。\n-XX:+UseFMA ,-XX:+UseVectorCmov ,-XX:+UseSHM ,-XX:+UseNewLongLShift ,-XX:+UseFastStosb ,这几个选项要求启用一些CPU相关的快速指令，要是你的CPU不支持其中的某一些，就直接删除掉吧。不过一般来说即使不支持也只是单纯的输出一条警告而已。\n3. 测试我们使用 Spark 进行测试，来对比这份参数与另一份网上流传很广的G1GC参数。\n在这里，我就使用我自己的服务器进行举例，为了模拟性能捉急的机器，我手动将-Xmx参数设置为10G\n为了让服务器有足够高的负载，我将实体限制提升到5000，并且召唤300只凋零来攻击不断被命令方块刷出的牛牛君。\n相关的报告可以在 https://spark.lucko.me/srA9dF1wkS （ZGC） 与 https://spark.lucko.me/gzX9cV3xdL （G1GC）看到\nTPS 对比:\nZGC  : 20.00(1m)/19.50（5m）\nG1GC : 19.31(1m)/19.74 (5m)\n\nMSPT 对比:\nZGC  : 0.519(最低)/18(平均)/43.2(95%ile)\nG1Gc : 0.593(最低)/20(平均)/54.4(95%ile)\n\nCPU 对比:\nZGC  : 4.59%（5m）\nG1Gc : 5.81%（5m）\n\n内存占用对比: \nZGC  : 2 GB/9.6 GB\nG1Gc : 3.8 GB/10 GB\n\n虽然不能说完胜吧，但是还是有了不少的提升的，而且随着运行时间变长，使用我的参数性能应当会越来越好（因为有更加激进的Jit方案），而G1则可能更加频繁的STW.\n看起来还不错？但是，在之前我们说过，对我好并不等于对你好，适合自己的才是真的好，在内存非常小的情况下，ZGC反而会占用非常高的CPU，如果你发现你的mspt飙升并且出现了GC分配停顿的状况，则应该考虑换回G1GC。\n","categories":[],"tags":["Minecraft"]},{"title":"关于","url":"/about/","content":"","categories":[],"tags":[]}]