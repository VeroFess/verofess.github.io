[{"title":"一些网络安全方面的基础科普 - P2 操作系统安全从入门到放弃","url":"/27113fa2a38a/","content":"这是一些我很久之前写的课件，当时还年轻，写的肯定有诸多不好的地方，还请见谅\n这篇文章主要是介绍了基础概念，详细的分析请关注后续\n0x01 看完这篇文章之后能学会一些什么?这篇文章看完之后就可以学会病毒及木马的分析, 化身网络安全工程师, 从此走向人生巅峰 — 这是不可能的.\n这篇文章的目的只是对基础操作系统安全的普及, 来帮助大家在以后的实验和工作中避免受到恶意软件的攻击\n0x02 开始之前,我们需要什么?一点点的耐心\n0x03 为什么不要使用破解版的软件?在平时使用电脑的过程中, 可能会使用到一些绿色版或者破解版的程序, 有的时候, 它们是打好包的应用程序, 有的时候, 则是提供了一些叫做破解器的小工具\n通常来说, 杀毒软件并不待见它们, 分分钟就把他们扫地出门, 但是这是为什么呢?\n通常来说, 一个最简单的应用程序的注册逻辑是这样的\n如果 (用户输入的注册码 等于 真正的注册码) 那么\t提示注册成功并且继续执行;否则\t提升注册失败并退出\n\n那么我们只要修改它的代码, 使它变成\n如果 (用户输入的注册码 不等于 真正的注册码) 那么\t提示注册成功并且继续执行;否则\t提升注册失败并退出\n\n就可以很简单的绕过\n那么杀毒软件为啥不待见他呢?\n假设, 我们有一个木马, 想要盗取某个软件的账号, 原始软件的逻辑是\n如果 (用户输入的密码 等于 真正的密码) 那么\t提示登录成功并且继续执行;否则\t提升登录失败并退出\n\n那么木马就可以将代码修改为\n如果 (用户输入的密码 等于 真正的密码) 那么\t将密码发送一份到某服务器;\t提示登录成功并且继续执行;否则\t提升登录失败并退出\n\n\n\n可以看出, 修改器和木马干的事情都差不多: 篡改应用程序的原始逻辑, 加入恶意代码\n所以杀毒软件也分不出他到底做了什么,当然就杀掉啦~\n当然, 这仅仅是其中的一种形式, 任何以某种方式对用户或者计算机或网络造成破坏的软件都可以被认为是恶意代码，包括计算机病毒、木马、蠕虫、内核套件、勒索软件、间谍软件等。\n那么, 常见的恶意代码种类有哪些呢?\n\n后门：恶意代码将自身安装到一台计算机来允许攻击者访问，通常让攻击者只需很少认证甚至无须认证，便可连接到远程计算机，在本地系统执行命令。\n僵尸网络：与后门类似，允许攻击者访问系统，但所有被同一个僵尸网络感染的计算机将从一台控制命令服务器接收到相同的命令。\n下载器：下载其他恶意代码的恶意代码。通常在攻击者获得系统的访问时首先进行安装。\n间谍软件：从受害计算机上收集信息并发送给攻击者的恶意代码。比如：嗅探器、密码哈希采集器、键盘记录器等。\n启动器：启动其他恶意程序的恶意代码。通常采用非传统技术来启动其他恶意程序，以确保其隐蔽性，或者以更高权限访问系统。\nRootkit：用来启动其他恶意代码的恶意代码。通常与其他恶意代码（如后门）组成工具套装，来允许为攻击者提供远程访问，或者以更高权限访问系统。\n勒索软件：会通知用户系统中存在恶意代码，而除掉它们的唯一办法只有购买他们的“软件”。事实上，他们所卖软件的全部功能只不过将勒索软件进行移除而已。\n发送垃圾邮件的恶意代码：这类恶意代码在感染用户计算机后，会使用系统与网络资源来发送大量的垃圾邮件。\n蠕虫：可以自我复制和感染其他计算机的恶意代码\n\n同时, 利用一些程序的漏洞和特殊功能(如office的宏), 也可以进行攻击\n所以说, 道理我都懂, 但是应该怎么保护我的电脑?\n最简单的方式就是 \n*** 拒绝盗版及来如不明的软件, 只使用来自可信渠道的软件 ***\n那么又如何保证下载到的软件是来自我们想要的提供者呢?\n当然, 这是不现实滴, 所以, 让我们打开 IDA Pro 和 &lt;恶意软件分析实战&gt; … 等一下先别打我, 有两种方法, 数字签名和哈希值\n简单地说,所谓数字签名就是附加在数据单元上的一些数据,或是对数据单元所作的密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据,防止被人进行伪造。而哈希值，是一种从任何一种数据中创建小的数字“指纹”的方法。\n通常来说, 在软件的下载界面会提供一串哈希值, 或者提供一个Sig文件, 当软件下载完成之后, 我们需要使用小工具来计算所需要的哈希值, 并且和网页上的值进行对比\n通常来说, 在搜索引擎上搜索”操作系统 哈希类型 工具”就会获得很多下载, 如可以直接搜索 “linux sha256 工具”.\n关于数字证书, 在Windows的操作系统上对着任意的文件右键, 如果他带有褐发色数字签名, 那么你会在数字签名的标签页下方看到他的状态,点击详细信息,则正常的程序应该显示”此数字签名正常”. 而linux 操作系统则需要下载一些额外的小工具\n0x04 别说这么多, 我就是想用!0x04 - 1 软件更新: 防患于未然之中更新主要分为两大类, 功能性更新以及安全更新, 功能性更新显而易见是提供了新的功能, 而安全性更新则是提供了一些安全方面的改进\n在编写代码的时候, 难免会存在错误, 其中一些可以被利用的错误则变成了漏洞, 这些漏洞可能隐藏的很深(就像永恒之蓝), 而攻击者则可以利用这些漏洞干坏事, 包括但不限于让程序崩溃, 盗取个人信息, 远程控制电脑等\n通过软件补丁, 我们可以及时的修复这些已知的漏洞,让攻击者不得不挖掘新的漏洞, 同时可以避免那些只会使用现有工具的恶作剧玩家的攻击\n0x04 - 2 权限管理: 凭票出入权限管理的核心是访问控制, 常见的域账户,UAC,SELinux等等都属于权限管理的范畴, 它的核心思想是\n\n防止非法的主体访问受保护的资源。\n允许合法用户访问受保护的资源。\n防止合法的用户对受保护的资源进行非授权的访问。\n\n设想一下，如果一个以 root 身份运行的网络服务存在 0day 漏洞，黑客就可以利用这个漏洞，以 root 的身份在服务器上为所欲为了。是不是很可怕？\n最小权限原则限制代码运行所需的安全权限，之所以这么做,  有一个非常重要的原因，就是降低你的代码在被恶意用户利用时造成的损失。如果你的代码仅仅使用最小权限来执行，恶意用户就难以使用它造成损失。如果你使用管理员权限来执行代码，那么任何代码中的安全缺陷都会潜在造成更大的损失。\n在分配权限的时候,要考虑以下的问题:\n\n程序需要该权限吗？\n如果程序不需要任何特殊权限来运行，它不应该是个特权程序。\n\n\n程序需要所有权限吗？\n我们只给予程序完成任务所需的最小权限集合。\n多数现代 Unix 系统（和 Windows）引入了更多选择。这些系统将 Root 权限划分为多种子权限。使用这种自粒度，我们就可以更好应用最小权限原则\n\n\n程序现在需要权限吗？\n程序通常偶尔不需要特定权限，它们在这个时候就变得不必要了。我们应该暂时禁用它们来满足最小权限原则。这么做的好处就是，防止程序犯下意外的错误，使之不能对需要禁用权限的事情造成损失。\n\n\n程序在未来需要权限吗？\n如果权限不再需要了，它就是不必要的，应该永久删除，所以最小权限集合应基于未来的需求来调整。\n\n\n\n0x04 - 3 杀毒软件: 系统的监管者反病毒软件的任务是实时监控和扫描系统。部分反病毒软件通过在系统添加驱动程序的方式，进驻系统，并且随操作系统启动。大部分的杀毒软件还具有防火墙功能。\n反病毒软件的实时监控方式因软件而异。\n有的反病毒软件，是通过在内存里划分一部分空间，将电脑里流过内存的数据与反病毒软件自身所带的病毒库（包含病毒定义）的特征码相比较，以判断是否为病毒。\n另一些反病毒软件则在所划分到的内存空间里面，虚拟执行系统或用户提交的程序，根据其行为或结果作出判断。\n而扫描磁盘的方式，则和上面提到的实时监控的第一种工作方式一样，只是在这里，反病毒软件将会将磁盘上所有的文件（或者用户自定义的扫描范围内的文件）做一次检查。\n关于杀毒软件大家都很熟悉了, 但是有些时候杀毒软件提示了风险, 我们依然想要执行这些带有风险的程序, 那么怎么办呢?\n0x04 - 4 沙盒与容器: 构建安全的环境想象一下，在一个装满了平整细沙的盒子里，我们可以尽情随意地在上面作画、涂写，无论画的好坏，最后轻轻一抹，沙盒又回到了原来的平整状态。沙盒的魅力就在于他允许你出错，还可以给你改正的机会\n沙盒技术提供对资源的严格控制，通过限制对内存、系统文件和设置的访问，允许执行恶意代码而不会影响主机设备。\n沙盒可以通过执行潜在恶意代码而发现其活动和意图, 这种针对行为的分析意味着，即使是0day漏洞利用都可以被发现\n当然, 它的缺点也显而易见: 它的安全性依赖于操作系统的安全性, 如果操作系统本身不够安全, 那么沙盒的保护就有被破坏的风险\n0x04 - 5 虚拟机: 完全隔离的解决方案虚拟机指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。\n理论上, 一个配置得当的虚拟机是非常安全的, 可以用来调试已知具有恶意行为的代码, 当然, 要是这还不能满足安全性要求,那么只能…\n0x04 - 6 物理隔离: 终极大杀器靠软件实现的安全方案总会有不足, 比如Intel的CPU不是才出了漏洞. 所以真正安全的解决方案是将个人电脑与工作电脑分开, 互不干涉\n0x05 关注威胁情报0x05  - 1 为什么会有威胁情报？如今，新一代的攻击者常常向企业和组织发起针对性的网络攻击。这样的网络威胁，用术语来说就是“高级持续性攻击”（Daly (2009)）。这种针对特定企业或行业的攻击，一般经过了精心的策划，攻击方法错综复杂，常导致严重的数据泄露或者破坏。\n最近几个备受关注的案例包括：网络犯罪者向零售商、银行和其他组织发起针对性攻击，以获得经济利益；“激进黑客”（hacktivist）和国家背景的黑客攻击媒体、金融组织、政府机构，以实现政治目的。其他的案例包括：私营或国营企业盗取国防企业及制造商的工程和业务流程信息；懂金融的黑客攻击医疗和制药公司，来获取影响股票价格的内部信息。\n这些黑客不断改变现有的攻击方式，开发新的方法；单独依赖防火墙、入侵防御系统和反病毒软件，无法阻止这些黑客的攻击。这类攻击无法通过恶意程序签名或者过去的攻击技术报告进行检测。而且，实际上，大多数企业面临的现状是收到的原始威胁数据过多：有太多警报，太多漏洞预警和补丁，太多关于各类恶意软件、钓鱼攻击和DDoS攻击的报告。\n急速增长的针对性网络攻击直接催生了威胁情报服务。或者用现在流行的一句话来概括即：攻防不对等——而威胁情报的出现就是为了尽可能消除这种不对等。\n0x05 - 2 为什么要关注威胁情报?在发生安全事件是, 我梦可以通过安全情报来保证自己的环境中出现薄弱的点的时候, 能够提前感知并且修复风险\n0x06 APT - 高级持续威胁高级长期威胁（英语：advanced persistent threat，缩写：APT），又称高级持续性威胁、先进持续性威胁等，是指隐匿而持久的电脑入侵过程，通常由某些人员精心策划，针对特定的目标。其通常是出于商业或政治动机，针对特定组织或国家，并要求在长时间内保持高隐蔽性。高级长期威胁包含三个要素：高级、长期、威胁。高级强调的是使用复杂精密的恶意软件及技术以利用系统中的漏洞。长期暗指某个外部力量会持续监控特定目标，并从其获取数据。威胁则指人为参与策划的攻击。\nAPT发起方，如政府，通常具备持久而有效地针对特定主体的能力及意图。此术语一般指网络威胁，尤其是指使用众多情报收集技术来获取敏感信息的网络间谍活动，但也适用于传统的间谍活动之类的威胁。其他攻击面包括受感染的媒介、入侵供应链、社会工程学。个人，如个人黑客，通常不被称作APT，因为即使个人有意攻击特定目标，他们也通常不具备高级和长期这两个条件。\nAPT并无准确定义，但总体可归纳如下：\n\n高级 – 威胁的幕后操纵者对情报收集技术有着全面的掌控能力。其中可包括电脑入侵技术和传统情报收集技术（如电话监听技术、卫星成像技术）。攻击中使用的各个组件本身可能并不能算特别“高级”（例如，利用公开的恶意软件生成工具生成的恶意软件，或是一些容易获得的漏洞利用材料），但是操纵者往往可以按需开发出更高级的工具。他们一般会使用多种针对方式、工具和技术以入侵目标，并保持访问权限。操纵者也可能会特别注意行动中的安全，这一点和“不那么高级”的威胁有所不同。\n长期 – 操纵者注重一个特定的任务，而不是盲目搜寻信息。这一区别暗示攻击者受到外部力量指示。为了达到预定目的，攻击者会持续监控目标，并做出反应。这并不表示攻击者会经常发动攻击、频繁更新恶意软件。事实上，“放长线”的方法会更为成功。如果操纵者失去了对目标的访问权，他们一般会重新尝试入侵，也往往会成功。操纵者的目的之一就是对目标保有长期的访问权，而不是一次性的访问权。\n威胁 – APT之所以成为威胁，是因为发起方既有此能力，又有此意图。APT攻击是由一群有组织的人发起的。操纵者有特定的目标，且技术精湛、资金雄厚。\n\n0x08 ARK工具简介ARK是英语Anti Rootkit的缩写，运行这类工具软件时，软件可以通过使用系统最高权限，对系统进行最高级别的设置管理。代表软件为PC Hunter, 它们可以做什么呢?\n\n进程&#x2F;内存&#x2F;线程&#x2F;模块&#x2F;句柄&#x2F;窗口管理\n内核模块查看\n网络连接查看和禁止\n查看&#x2F;恢复SSDT和Shadow SSDT\n扫描&#x2F;恢复RING3和RING0的内联钩子\n查看并删除消息钩子\n查看&#x2F;恢复重要驱动程序分发函数\n查看&#x2F;恢复内核对象例程钩子\n枚举各种通告和回调\n枚举I&#x2F;O定时器\n…\n\n当然, 这只是一小部分功能, 如果真的想分析病毒木马, 这里推荐一本书, 叫做&lt;恶意软件分析实战&gt;, 这里就不进行额外的介绍了, 如果没有把握,还是不要在电脑上运行这种工具了.\n0x09 思考题时间\n为什么前两课的时候需要安装两台虚拟机?如果将所有的工具都直接安装在操作系统上可以么?为什么?\n在第一课布置DVWA的时候我们做了哪些安全措施?分别是提高了安全性或者降低了安全性?\n在DVWA的漏洞环境中, 我们可以通过上面提到的的什么方式来缓解已知的漏洞攻击?为什么选择它而不是别的?\n公司安全条例中的禁止外借域账号与VPN账号是出于什么方面的考量?为什么会配备工作计算机?\n打开未知的office文件使用上面的哪种方式比较好? 一个破解版软件呢? 为什么?\n\n","categories":["科普"],"tags":["信息安全","科普"]},{"title":"强制让小米AOD只能亮五分钟的机型保持AOD常亮","url":"/2f586df9bdee/","content":"为了轻薄买了个小米的Civi，然后发现AOD五分钟就灭了，你这ADO了个寄吧.jpg\n解决方式也很简单，adb shell 进去, 执行\nsettings put secure aod_mode_time 2\n\n","categories":["折腾记录"],"tags":["安卓"]},{"title":"一些网络安全方面的基础科普 - P1 识别恶意软件","url":"/d4ad30414b22/","content":"这几天看到了一些比较肆虐而且比较常见的互联网病毒传播，所以专门写篇文章聊一聊这个问题\n特别一提，由于本文的性质，本文章为公共领域文章，即在世界范围内放弃本文的所有权利，故任何人都可以以任何方式转载或重新发布\n当然，如果你可以保留指向本文章的链接那就再好不过了，因为本文章可能会更新，保留链接可以使读者获得及时的更新\n本文章虽然是面向Windows的，但是安卓或者其他平台举一反三也可以用，本文章的方案只是个人经验，常在河边走总会踩进去！\n01 手把手的入门! 浅谈一下比较泛用的病毒(恶意软件)识别方式01-1 万事开头难: 误报对于对信息安全方面不太熟悉的朋友来说，有一个词很熟悉: 误报\n误报这个问题具体来说就是因为某些软件(外挂, 破解器)的行为和病毒实在是太像了，导致杀毒软件不能准确的识别\n于是有些病毒作者就把思路打开了: 如果杀毒软件会把病毒和破解工具搞混，那是不是可以把他们捆绑在一起让用户手动放行呢？\n没错，是这样的，并且有很大一部分的病毒也正是这样传播的，所以，支持正版，不要开挂是预防病毒很好的手段\n哎哎别关网页，肯定有人要说了: “你这说了个JB”，别慌，接下来是正题\n看之前请记住，以下的分析并不能替代杀毒软件的动态监测\n也请不要抱着: 我也没啥值钱的东西感染就感染了呗\n现代的木马盗号已经是轻的了，冒充你的信息贷款，使用你的电脑攻击其他设备或者进行其他违法行为才是需要警惕的，毕竟警察看到的是从你的设备发出的攻击\n01-2 Virus Total: 简单，高效的恶意文件分析识别网站接下来，就是我们的正题: 如何将外挂等工具与木马病毒区分开来\n当然，如果你是卡巴斯基用户…只需要右键一下…\n\n咳咳，跑题了，先放链接: Virus Total\n打开上面的链接，你会看到这样的页面\n\nOK, 这就是我们的主角了，具体它是什么网站感兴趣的可以自行查询\n主页很简单，点击 Choose file 按钮或者将文件拖拽到中间的图标上[参考下图]即可上传文件进行分析\n\n拖拽上去之后，如果你的文件从来没有人上传过，会弹出一个窗口要求你确认上传[参考下图]，点击中间的 Confirm upload 按钮即可上传。 请注意，你所上传的文件，对于专业的安全研究人员来说，是可以下载的，请不要上传涉及机密以及个人隐私的文件\n\n新的文件可能需要一些时间来扫描，等扫描结束之后，我们即可看到结果页面，大概长下面这样\n\n首先，最主要的部分就是文件安全概览部分，也就是下图中的部分\n\n左边的圆环 [图中标有 1 的方框] 代表着有多少杀毒软件认为这个文件是带有恶意的，在这张图中，总共有70个杀毒软件对文件进行了扫描，其中有0个杀毒软件将其汇报为恶意\n圆环的下方 [图中标有 2 的方框] 代表有多少VT的用户认为这个文件是恶意或者善意的，图中只有我自己投了一票，所以上面的评分是问号。这个评分是个人就能投，目前对于恶意刷票是否有惩罚我没有了解，所以它并不能权威的表示这个文件具体的行为，但是具有一定的参考价值\n在整体靠右的位置 [图中标有 3 的方框]，代表这个文件第一次上传是什么时候，可以看到我选择的文件在五天前第一次被上传，通常来说，较旧的文件(大于半年)的结果是比较准确的，因为不明确的文件大概率都被各大安全公司已经拖回去手动分析过了，而较新的文件可能存在漏检的问题，因为病毒也会尝试新的技术来躲避杀毒软件的追踪\n继续向下看，就可以看到几个分页 [见下图]，点击任意标题即可跳转到对应的页，四个标签分别对应着 **杀毒软件检测结果 [图中标有1的方框]，文件详情 [图中标有2的方框]，该文件的行为(就是他执行之后干了啥) [图中标有3的方框]，社区评分的详情 [图中标有4的方框，对应上一张图的2号框]**，\n\n其中，我们在 杀毒软件检测结果 页中，主要关注 如果杀毒软件报毒，那么杀毒软件认为他是个什么东西，即下图中红色字体的部分 (下图中，为了演示我换了一个报毒的样本)\n\n而另外几个标签页，则会结合杀毒软件检测结果中的信息综合使用，详见下文\n在接下来的文章中，我会选择四类文件进行分析，分别是 完全可信的文件, 大概率可信的文件, 有疑点但是也许可信的文件, 大概率不可信的文件，并向大家指出如何区分它们.\n01-3 典型的完全可信文件这一部分最为简单，一个典型的白名单文件应该做到什么呢？代码透明，没有恶意行为，有可信任的文件发布者，满足这点即可放心的使用\n在这里，我使用了自己的 EV 证书签名了一个来自 Google Android Platform Tools 的文件，并将其上传至 Virus Total，可以点击这个链接 查看\n对于这个文件，72个杀毒软件对其进行了测试，其中有0个杀毒软件将其标记为了病毒\n同时我们点击文件详情(忘了在哪里？回去看看吧 XD)， 向下拖，可以看到有一个叫做签名信息的区域，其中有一行带有绿色对勾的 Signed file, valid signature , 表明该文件经过了数字签名(什么是数字签名? 点这里 或者 点这里 查看科普)，同时该文件的签名人持有的是EV证书(什么是EV证书? 点这里查看科普) 所以该文件大概率是可信的. [见下图]\n\n01-4 大概率可信的文件这里我们选择了一个来自 Github 的文件，其报告可以从 这里 查看，大部分情况下，我们使用的一些小工具并没有进行数字签名(贵啊!)，不过相对来说，还是比较好区分的\n首先，没有任何杀毒软件对其报毒，这很好，其次，虽然它没有签名，但是他也没有任何的异常行为(见下图红框)，所以我们认为他是可信的\n\n01-5 有疑点但是也许可信的文件接下来，也就是本文的重点难点，怎么样区分误报和真正的恶意软件\n在阅读以下文本之前，强烈建议你先看看 来自卡巴斯基的恶意软件科普及命名简介\n首先，先回顾一个问题: 为什么会有误报发生? 是因为某些软件(外挂, 破解器)的行为和病毒实在是太像了，导致杀毒软件不能准确的识别\n另一个方面，误报通常发生在用户使用量较小的杀毒软件上，这很好理解，因为用户量大的杀毒软件通常都针对误报做了足够好的优化，一般我认为在 ESET-NOD32, Avast, Comodo, BitDefender, Kaspersky, Symantec，Microsoft, Rising, Tencent 算是大厂，因为他们的用户量比较大\n最后，误报通常都 不 会显示出有意义的病毒种类信息，因为杀毒软件只是因为不认识或者怀疑而报毒，而并不是因为识别出了具体的行为\n拿风灵月影 举个例子\n\n虽然有22个杀毒软件认为他不是好东西，但是大家都基本可以认出来他是 GameHack, 3DMGAME Trainer, 而上面的大厂列表中，最严重的是 Comodo 的 ApplicUnwnt ， 也就是说本身不是恶意， 也许只是对你没有啥用的软件，所以虽然他看起来很多报毒，但是实际上并没有啥大问题\n\n再换个例子，另外一款游戏修改器\n\n只有四款杀毒软件认为其有恶意，其中 Symantec 的报毒原因是来源于机器学习 … 总之，IDS也没有啥严重的规则命中，我们也基本可以信任它。\n\n接下来我们上点难度，用非外挂软件 举个例子 , 这个链接中的样本有 9 &#x2F; 67 的杀毒软件认为他是病毒\n\n我们先看，其中有三款杀毒软件将文件简单的将文件标为 Malicious（恶意），针对这个结果，我们等下看\n有三款杀毒软件明确的告诉我们，他们只是怀疑这个程序，分别是 ESET-NOD32 的 A Variant Of Win64&#x2F;Packed.VMProtect.J Suspicious（使用了加壳工具VMProtect的可疑程序），SentinelOne (Static ML) 的 Static AI - Suspicious PE （可疑的PE文件），Sophos 的 Generic ML PUA (PUA) （PUA: 不需要的软件，也许是垃圾软件） \n当然了，有的朋友肯定要说了，你知道他们代表的是啥，我又不知道啊！首先，我们可以尝试搜索 报毒的杀毒软件名 &lt;空格&gt; 汇报的病毒名称，例如我们搜索 Sophos Generic ML PUA (PUA) 搜索引擎会给我们以下的结果 \n\n这次很幸运，头两个结果将会把我们带到杀毒软件的官方文档，点击进去 会看到杀毒软件将其描述为 潜在有害应用程序 （PUA） 是一个术语，用于描述虽然不是恶意的，但通常被认为不适合业务网络的应用程序，也就是说通常不包含恶意\n而 SentinelOne 的汇报则简单明了，直接说明了是可疑的文件，我们先跳过不管\nESET-NOD32 的情况则稍微有一些复杂，我们的搜索结果大概长这样\n\n我们通过阅读开始的几篇文章 不是卖软件 的文章即可了解并推断，这种误报是相当常见的\n接下来，我们继续查看最后的几款杀毒软件，在互联网上搜索，发现针对 Trojan.Malware.300983.susgen 的反馈大多是误报，Trojan.Heur!.02292022 几乎没有有用的信息，Generic.mg.6a3cf94332d7fa61 更是几乎没有关联的网页\n最后我们看看大厂，在 ESET-NOD32, Avast, Comodo, BitDefender, Kaspersky, Microsoft, Rising, Tencent 中，只有一家汇报了风险，而且是怀疑，所以这个文件大概率没有问题\n\n总结一下，如果大家都认为一个样本属于 GameHack, PUA, HACKTOOL 之类的标签，那么他大概率是没啥问题的，如果一些软件为了防止破解加了很重的保护，那么大概率也是误报，最终可以依据 ESET-NOD32, Avast, Comodo, BitDefender, Kaspersky, Symantec，Microsoft, Rising, Tencent 的报告做出决定，如果他们都觉得没啥事，那大概率是误报，但是如果他们中有 两个及以上 认为这个程序有害，那大概率就是真的有问题\n01-6 正儿八经的恶意程序接下来我给大家看看正经的恶意程序长啥样\n安卓偷照片的勒索病毒\n\nKaspersky, ESET-NOD32, Avast，BitDefender 均准确的识别出这是 Spy Trojan（窃取信息的木马）\nWindows下面的远程控制木马\n\n这还用说？满脸都是”我是木马”\n\n总之，基本卡巴斯基（Kaspersky）报毒，他就真的是毒，所以卡巴红了就…别用了\n\n本篇到这里就写完了，下一篇教大家，如果真的很想用，那么应该怎么搭建一个安全的环境\n我很少写这样基础向的文章，如果有什么问题可以联系我，例如推特 @VeroFess\n下次见！\n","categories":["科普"],"tags":["信息安全","科普"]},{"title":"CSharp中实现一个可继承的Singleton基类","url":"/f72f727a78aa/","content":"网上大部分的单例实现都要求在类里添加一个”GetInstance()”并且声明私有的构造函数,额外多了几行没啥用且重复的代码,一不小心还会忘记把构造函数搞成私有的,非常不爽,所以就搞了个这东西\n不多说,上代码,使用的时候只需要public class ClassName : Singleton&lt;ClassName&gt;即可,获取实例直接ClassName.Instance,无需额外的更改\nusing System;using System.Collections.Generic;namespace InstanceHelper.Singleton &#123;    public class Singleton&lt;T&gt; &#123;        private static Dictionary&lt;Type, Object&gt; TypeObjectMap = new Dictionary&lt;Type, Object&gt;();        private static List&lt;Type&gt; TypeLoadList = new List&lt;Type&gt;();        static public T Instance &#123; get =&gt; GetInstance(typeof(T)); &#125;        public Singleton() &#123;            lock (TypeLoadList) &#123;                if (!TypeLoadList.Contains(this.GetType())) &#123;                    throw new NewSingletonClassException(String.Format(&quot;Class &#123;0&#125; is Singleton, Use \\&quot;&#123;1&#125;.Instance;\\&quot; but \\&quot;new &#123;1&#125;();\\&quot;&quot;, this.GetType().FullName, this.GetType().Name));                &#125;            &#125;        &#125;        private static void LockUnregisterTypeLoadStatus(Type _Type) &#123;            lock (TypeLoadList) &#123;                if (TypeLoadList.Contains(_Type)) &#123;                    TypeLoadList.Remove(_Type);                &#125;            &#125;        &#125;        private static void LockRegisterTypeLoadStatus(Type _Type) &#123;            lock (TypeLoadList) &#123;                if (!TypeLoadList.Contains(_Type)) &#123;                    TypeLoadList.Add(_Type);                &#125;            &#125;        &#125;        protected static T GetInstance(Type _Type) &#123;            if (!TypeObjectMap.ContainsKey(_Type)) &#123;                lock (TypeObjectMap) &#123;                    if (!TypeObjectMap.ContainsKey(_Type)) &#123;                        LockRegisterTypeLoadStatus(_Type);                        var Instance = Activator.CreateInstance(_Type);                        LockUnregisterTypeLoadStatus(_Type);                        TypeObjectMap.Add(_Type, Instance);                    &#125;                &#125;            &#125;            return (T)TypeObjectMap[_Type];        &#125;    &#125;&#125;","categories":["开发笔记"],"tags":["CSharp"]},{"title":"一份面向Linux下高版本Java的Minecraft参数优化教程","url":"/e6ad4dc21152/","content":"前排提示:[!] 注意，该教程仅面向具有独立服务器的情况，如果你是面板服，就不用看了[!] 注意，该教程假定你有一块还算不错的CPU,2.XHz的就别看了[!] 注意，该教程需要一定的Linux知识，并且假定你正在使用Ubuntu，其它系统自己百度0. 一些废话和声明Q: 为什么要写这一篇帖子？\nA: 这两天在开服，随手翻看了几篇优化帖子，发现都是基于老版本Java的，于是就想写一篇新的。\n\nQ: 我可以转载这篇帖子么？\nA: 很抱歉，你不可以这么做，除非你联系我(MCBBS, Twitter, 知乎：@VeroFess)并获得了明确的授权\n\n\n1. 服务器准备1.1 升级Java为啥要升级Java？很简单，更新的Java可以获得更好的性能，但是在高版本里其实你选择哪个Java的影响已经不是很大了。\n不论如何，请使用你的方法安装Java 17，最好是Jdk, 完成后， 输入 java --version, 来检查一下是否安装正常\n你应该可以看到类似的输出\n$ java --versionopenjdk 17.0.3 2022-04-19OpenJDK Runtime Environment (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)OpenJDK 64-Bit Server VM (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1, mixed mode, sharing)\n\n1.2 开启大页支持大页 (LargePages) 究竟有什么好处并不是我们今天的重点，一句话来说就是可以让你白捡百分之十几的性能\n当然，在动手前，让我们先试一试是不是系统已经支持了这项功能\n在控制台中， 输入 java -Xlog:gc+init -XX:+UseLargePages -Xmx1g -version , 你应该会看到类似的输出\n$ java -Xlog:gc+init -XX:+UseLargePages -Xmx1g -version[0.000s][warning][pagesize] UseLargePages disabled, no large pages configured and available on the system.[0.023s][info   ][gc,init ] Version: 17.0.3+7-Ubuntu-0ubuntu0.20.04.1 (release)[0.023s][info   ][gc,init ] CPUs: 16 total, 16 available[0.023s][info   ][gc,init ] Memory: 31972M[0.023s][info   ][gc,init ] Large Page Support: Disabled[0.023s][info   ][gc,init ] NUMA Support: Disabled[0.023s][info   ][gc,init ] Compressed Oops: Enabled (32-bit)[0.023s][info   ][gc,init ] Heap Region Size: 1M[0.023s][info   ][gc,init ] Heap Min Capacity: 8M[0.023s][info   ][gc,init ] Heap Initial Capacity: 500M[0.023s][info   ][gc,init ] Heap Max Capacity: 1G[0.023s][info   ][gc,init ] Pre-touch: Disabled[0.023s][info   ][gc,init ] Parallel Workers: 13[0.023s][info   ][gc,init ] Concurrent Workers: 3[0.023s][info   ][gc,init ] Concurrent Refinement Workers: 13[0.023s][info   ][gc,init ] Periodic GC: Disabledopenjdk version &quot;17.0.3&quot; 2022-04-19OpenJDK Runtime Environment (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)OpenJDK 64-Bit Server VM (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1, mixed mode, sharing)\n\n如果你像我一样， 有一行 UseLargePages disabled, no large pages configured and available on the system. 那么就说明当前系统并不支持大页，不过不要急，可以试一下这一行命令 java -Xlog:gc+init -XX:+UseTransparentHugePages -Xmx1g -version , 你应该会看到类似的输出：\n$ java -Xlog:gc+init -XX:+UseTransparentHugePages -Xmx1g -version[0.024s][info][gc,init] Version: 17.0.3+7-Ubuntu-0ubuntu0.20.04.1 (release)[0.024s][info][gc,init] CPUs: 16 total, 16 available[0.024s][info][gc,init] Memory: 31972M[0.024s][info][gc,init] Large Page Support: Enabled (Transparent)[0.024s][info][gc,init] NUMA Support: Disabled[0.024s][info][gc,init] Compressed Oops: Enabled (32-bit)[0.024s][info][gc,init] Heap Region Size: 1M[0.024s][info][gc,init] Heap Min Capacity: 8M[0.024s][info][gc,init] Heap Initial Capacity: 500M[0.024s][info][gc,init] Heap Max Capacity: 1G[0.024s][info][gc,init] Pre-touch: Disabled[0.024s][info][gc,init] Parallel Workers: 13[0.024s][info][gc,init] Concurrent Workers: 3[0.024s][info][gc,init] Concurrent Refinement Workers: 13[0.024s][info][gc,init] Periodic GC: Disabledopenjdk version &quot;17.0.3&quot; 2022-04-19OpenJDK Runtime Environment (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)OpenJDK 64-Bit Server VM (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1, mixed mode, sharing)\n\n注意到 Large Page Support: Enabled (Transparent) 了么？说明我们的系统是支持透明大页的。\n但是如果你依然不支持或者想要追求极致性能，可以去百度搜索当前的系统如何开启大页，这里就不再过多的赘述了。\n\n2. 启动参数2.1 G1GC vs.ZGCGC引擎的选择是一个老生常谈的问题了，同其他教程不同，我本人更加推荐ZGC。\n理由很简单，现在的CPU动辄八核十六核，但是MC又是一个出了名的吃单核游戏，用其他核心的时间换主核心的无暂停是很划算的事情。\nG1GC在设计之初考虑的是吞吐量和占用的均衡，而ZGC则是用更加高昂的CPU代价换取主线程无停顿，这对我们来说简直是刚好。但是并不是每一个人都适合ZGC，在接下来的文章里我会教你怎么样查看自己适不适合它。\n2.2 来吧！启动参数！2.2.1 总览准备好, 参数要来了，有点长，不过我会分段告诉你他们的作用。\njava -server -Xmx$&#123;memory&#125;M -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+DisableExplicitGC -XX:-UseG1GC -XX:+UseZGC -XX:-ZUncommit -XX:+UseTransparentHugePages -XX:+UseHugeTLBFS -XX:LargePageSizeInBytes=1g -XX:ReservedCodeCacheSize=512M -XX:MaxInlineSize=256 -XX:+AlwaysPreTouch -XX:+OmitStackTraceInFastThrow -XX:+DoEscapeAnalysis -XX:+OptimizeStringConcat -XX:+EliminateLocks -XX:+UseBiasedLocking -XX:+SegmentedCodeCache -XX:+UseVectorCmov -XX:+UseSHM -XX:+UseNewLongLShift -XX:+UseFastStosb -jar $&#123;core&#125;.jar\n2.2.2 那些不太需要说的部分-Xmx$&#123;memory&#125;M 和 -jar $&#123;core&#125;.jar 这两个参数，着实是不用说…\n2.2.3 基础！-server 这个参数吧，我自己测试确实是有一定的效果的，但是也没其他帖子说的这么夸张，总之加上肯定没错。\n而 -XX:+UnlockExperimentalVMOptions 和 -XX:+UnlockDiagnosticVMOptions 这两个参数，纯粹是我懒得去看后面的一大串是不是在他们的影响列表里，所以加上的。\n2.2.4 内存管理调整-XX:+DisableExplicitGC，-XX:-UseG1GC，-XX:+UseZGC，-XX:-ZUncommit，-XX:+UseTransparentHugePages，-XX:+UseHugeTLBFS，-XX:LargePageSizeInBytes=1g，-XX:ReservedCodeCacheSize=512M，-XX:MaxInlineSize=256和-XX:+AlwaysPreTouch属于内存调整参数。\n首先，我们通过-XX:+DisableExplicitGC来阻止显式的System.gc()调用，这倒不是说所有的手动调用都是不好的，但是总有些mod或者插件的编写者觉得调用的越频繁越好，但是过于频繁的GC反而会拖慢速度，所以索性就把这个方法干掉，让Java来帮我们管理。\n-XX:-UseG1GC，-XX:+UseZGC 这两个参数用来强制Jvm使用ZGC, 不需要做过多的解释\n-XX:-ZUncommit， -XX:+AlwaysPreTouch 这两个参数呢，要求Jvm总是提前把要用的内存申请好，并且阻止Jvm把临时空出来的内存还给系统，这样会节约不少内存分配的开销，当然，如果你的系统内存不够用，还是去掉这两个参数吧。\n-XX:+UseTransparentHugePages，-XX:+UseHugeTLBFS，-XX:LargePageSizeInBytes=1g 这三个参数用于启用大页支持，并且允许Jvm使用1G的大页， 如果你的系统支持非透明大页（也就是1.2中的第一个指令没有说不支持），就把-XX:+UseTransparentHugePages给改成-XX:+UseLargePages.\n-XX:ReservedCodeCacheSize=512M，-XX:MaxInlineSize=256这两个参数允许Jvm缓存更多Jit之后的代码，并且允许Jvm把一些比较短的方法做inline优化，是一种用比较小的内存代价来换取性能提升的方法。\n2.2.5 其他优化这一部分主要包含了 -XX:+OmitStackTraceInFastThrow， -XX:+DoEscapeAnalysis， -XX:+OptimizeStringConcat， -XX:+EliminateLocks 这四个参数。\n-XX:+OmitStackTraceInFastThrow 这个参数要求Jvm在遇到异常时省略异常栈，因为有一些编写不是很好的mod&#x2F;插件总是会抛出异常，这也算是一个可能不小的优化。\n-XX:+DoEscapeAnalysis 这个参数应该是默认启用的，他要求Jvm进行逃逸分析，并且以分析结果为依据进行其他优化，这里加上只是为了防止某些个例中这玩意由于未知原因被关掉。\n-XX:+OptimizeStringConcat 同样， 这个也应该是默认启用的，可以优化字符串拼接的效率。\n-XX:+SegmentedCodeCache 这个选项要求Jit编译器把代码拆分为小段，虽然会占用更多的内存，但是会加快运行的速度。\n-XX:+UseBiasedLocking 这个选项要求使用偏向锁，由于MC的锁竞争大多发生在主线程，这可以优化一些性能，虽然提示这个东西要移除了，但是能用一天是一天。\n-XX:+UseFMA ,-XX:+UseVectorCmov ,-XX:+UseSHM ,-XX:+UseNewLongLShift ,-XX:+UseFastStosb ,这几个选项要求启用一些CPU相关的快速指令，要是你的CPU不支持其中的某一些，就直接删除掉吧。不过一般来说即使不支持也只是单纯的输出一条警告而已。\n3. 测试我们使用 Spark 进行测试，来对比这份参数与另一份网上流传很广的G1GC参数。\n在这里，我就使用我自己的服务器进行举例，为了模拟性能捉急的机器，我手动将-Xmx参数设置为10G\n为了让服务器有足够高的负载，我将实体限制提升到5000，并且召唤300只凋零来攻击不断被命令方块刷出的牛牛君。\n相关的报告可以在 https://spark.lucko.me/srA9dF1wkS （ZGC） 与 https://spark.lucko.me/gzX9cV3xdL （G1GC）看到\nTPS 对比:\nZGC  : 20.00(1m)/19.50（5m）\nG1GC : 19.31(1m)/19.74 (5m)\n\nMSPT 对比:\nZGC  : 0.519(最低)/18(平均)/43.2(95%ile)\nG1Gc : 0.593(最低)/20(平均)/54.4(95%ile)\n\nCPU 对比:\nZGC  : 4.59%（5m）\nG1Gc : 5.81%（5m）\n\n内存占用对比: \nZGC  : 2 GB/9.6 GB\nG1Gc : 3.8 GB/10 GB\n\n虽然不能说完胜吧，但是还是有了不少的提升的，而且随着运行时间变长，使用我的参数性能应当会越来越好（因为有更加激进的Jit方案），而G1则可能更加频繁的STW.\n看起来还不错？但是，在之前我们说过，对我好并不等于对你好，适合自己的才是真的好，在内存非常小的情况下，ZGC反而会占用非常高的CPU，如果你发现你的mspt飙升并且出现了GC分配停顿的状况，则应该考虑换回G1GC。\n","categories":["折腾记录"],"tags":["Minecraft"]},{"title":"关于","url":"/about/","content":"","categories":[],"tags":[]}]